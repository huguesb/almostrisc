
extended instruction set :

	|F|E|D|C|B|A|9|8|7|6|5|4|3|2|1|0| 
	|-------------------------------|

v1
	|-------------------------------|
	|1 1 1 1|1 1 1 1|1 1 1 1|1 1 1 0| reti
	|-------------------------------|

v2?
	|-------------------------------|
	|1 1 1 0|1 0 0 0|0 0|  Ra |  Rd | push rd, ra <=> sw rd, ra \ dec ra
	|1 1 1 0|1 0 0 0|0 1|  Ra |  Rd | pop rd, ra <=> lw rd, ra \ inc ra
    |-------------------------------|
	|1 1 1 0|1 0 0 0|0 0|  Ra |  Rd | swap rd, ra <=> (ra, rd) = (rd, ra)
	|1 1 1 0|1 0 0 0|0 1|  Ra |  Rd | mswap rd, ra <=> ((ra), rd) = (rd, (ra))
    |-------------------------------|
    

 MUCH needed instructions
	* register swap (gnl)
	* stack manipulation (gnl) : no special purpose reg??? UAL hack???
	* interrupts-related (gnl)
	* multiplication/division (op)
	* streamed
	* add/sub with immediates?
	* conditionnal branch with link
	* 16 bit immediates (2 words instructions)

li rd, 0xdead => 0xlird
                 0xdead

baicc ra, 0xdead => 0xbaicc
                    0xdead

 ROOM for instructions :
 
	* UAL operations :
		candidates : scf, ccf, clrf, nand, nor, xnor, swaphi/lo, maskhi/lo
		
		* 4 between negb and and
			001100
			001101
			
			001110
			001111
			
		* 12 between not and shl
			010100
			010101
			
			010110
			010111
			
			011000
			011001
			
			011010
			011011
			
			011100
			011101
			
			011110
			011111

	* "variants" (assuming fixed value for 'x' bits) [spec apparently does not allow this...]
		* 63 "variants" of in
		* 63 "variants" of out
		* 7 "variants" of lw (conditionals?)
		* 7 "variants" of sw (conditionals?)
		* 7 "variants" of brl (conditionals?)
		* 7 "variants" of bal (conditionals?)
		
	* brand new
		* 11011  prefix : 2^11 = 2048 (from out to brcc)
		* 111001 prefix : 2^10 = 1024 (from brcc/bacc to ..)
		* 11101  prefix : 2^11 = 2048 (.. to brl/bal)
		* 111101 prefix : 2^10 = 1024 (from bal to xx)
		* 11111  prefix : 2^11-2 = 2046 (from xx to reset)
		
		=> 8k instruction slots
